From 66dbb01d1a5f02d63a529d0421c6641b70265b7b Mon Sep 17 00:00:00 2001
From: qjohn <townex22@gmail.com>
Date: Fri, 18 May 2018 17:11:45 +0000
Subject: [PATCH] base: Implement Dynamic System Bars [1/2]

 * Bring in to Oreo :p

Change-Id: I0df5d1b6fbc5ba14ed51e74ba27898eda986f196
Signed-off-by: qjohn <townex22@gmail.com>
---
 core/java/android/provider/Settings.java           |  35 ++
 packages/SystemUI/Android.mk                       |   1 +
 packages/SystemUI/jni/Android.mk                   |  34 ++
 .../jni/in_parashit_BarBackgroundUpdaterNative.cpp | 247 ++++++++++++
 .../jni/in_parashit_BarBackgroundUpdaterNative.h   |  46 +++
 .../statusbar/phone/BarBackgroundUpdater.java      | 439 +++++++++++++++++++++
 .../systemui/statusbar/phone/BarTransitions.java   | 318 +++++++++++----
 .../statusbar/phone/LightBarController.java        |  95 +++--
 .../statusbar/phone/NavigationBarTransitions.java  |  95 ++++-
 .../statusbar/phone/NotificationPanelView.java     |   2 +-
 .../statusbar/phone/PhoneStatusBarTransitions.java |  97 ++++-
 .../in/parashit/BarBackgroundUpdaterNative.java    |  29 ++
 proto/src/metrics_constants.proto                  |   3 +
 13 files changed, 1329 insertions(+), 112 deletions(-)
 create mode 100644 packages/SystemUI/jni/Android.mk
 create mode 100644 packages/SystemUI/jni/in_parashit_BarBackgroundUpdaterNative.cpp
 create mode 100644 packages/SystemUI/jni/in_parashit_BarBackgroundUpdaterNative.h
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/phone/BarBackgroundUpdater.java
 create mode 100644 packages/SystemUI/src/in/parashit/BarBackgroundUpdaterNative.java

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index ad010a8..22b5c2e 100755
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -3960,6 +3960,41 @@ public final class Settings {
          public static final String VOLUME_KEY_CURSOR_CONTROL = "volume_key_cursor_control";
 
         /**
+         * Whether the status bar is set to be colored dynamically
+         * 0 = disabled (default)
+         * 1 = enabled
+         * @hide
+         */
+        public static final String DYNAMIC_STATUS_BAR_STATE = "dynamic_status_bar_state";
+
+        /**
+         * Whether the navigation bar is set to be colored dynamically
+         * 0 = disabled (default)
+         * 1 = enabled
+         * @hide
+         */
+        public static final String DYNAMIC_NAVIGATION_BAR_STATE =
+                "dynamic_navigation_bar_state";
+
+        /**
+         * Whether the dynamic system bars are set to have a gradient overlay
+         * 0 = disabled (default)
+         * 1 = enabled
+         * @hide
+         */
+        public static final String DYNAMIC_SYSTEM_BARS_GRADIENT_STATE =
+                "dynamic_system_bars_gradient_state";
+
+        /**
+         * Whether the dynamic status bar is set to have a (darkening) filter overlay
+         * 0 = disabled (default)
+         * 1 = enabled
+         * @hide
+         */
+        public static final String DYNAMIC_STATUS_BAR_FILTER_STATE =
+                "dynamic_status_bar_filter_state";
+
+        /**
          * Settings to backup. This is here so that it's in the same place as the settings
          * keys and easy to update.
          *
diff --git a/packages/SystemUI/Android.mk b/packages/SystemUI/Android.mk
index 0e25717..9469632 100644
--- a/packages/SystemUI/Android.mk
+++ b/packages/SystemUI/Android.mk
@@ -50,6 +50,7 @@ LOCAL_JAVA_LIBRARIES += android.car
 LOCAL_FULL_LIBS_MANIFEST_FILES := $(LOCAL_PATH)/LineageManifest.xml
 
 LOCAL_PACKAGE_NAME := SystemUI
+LOCAL_JNI_SHARED_LIBRARIES := libParaSHITjni
 LOCAL_CERTIFICATE := platform
 LOCAL_PRIVILEGED_MODULE := true
 
diff --git a/packages/SystemUI/jni/Android.mk b/packages/SystemUI/jni/Android.mk
new file mode 100644
index 0000000..bed378c
--- /dev/null
+++ b/packages/SystemUI/jni/Android.mk
@@ -0,0 +1,34 @@
+# Copyright (C) 2018 ParaSHIT Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := in_parashit_BarBackgroundUpdaterNative.cpp
+
+LOCAL_C_INCLUDES += $(JNI_H_INCLUDES)
+
+LOCAL_SHARED_LIBRARIES := \
+    libgui \
+    libutils \
+    libui
+
+LOCAL_MODULE := libParaSHITjni
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_CFLAGS += -Wall -Werror -Wunused -Wunreachable-code
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/packages/SystemUI/jni/in_parashit_BarBackgroundUpdaterNative.cpp b/packages/SystemUI/jni/in_parashit_BarBackgroundUpdaterNative.cpp
new file mode 100644
index 0000000..7d61731
--- /dev/null
+++ b/packages/SystemUI/jni/in_parashit_BarBackgroundUpdaterNative.cpp
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2014 ParanoidAndroid Project
+ *           (C) 2016-2018 ParaSHIT
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <in_parashit_BarBackgroundUpdaterNative.h>
+
+#define LOG_TAG "BarBackgroundUpdaterNative"
+#define DEBUG_FLOOD false
+
+#define SHOT_SCALE 1
+#define ROTATION_0 0
+#define ROTATION_90 1
+#define ROTATION_180 2
+#define ROTATION_270 3
+
+#include <gui/ISurfaceComposer.h>
+#include <gui/SurfaceComposerClient.h>
+#include <ui/DisplayInfo.h>
+
+using namespace android;
+
+int screenRotation;
+
+void const * shotBase;
+
+uint32_t shotWidth;
+uint32_t shotHeight;
+uint32_t shotStride;
+PixelFormat shotFormat;
+
+uint32_t requestedShotWidth = 0;
+uint32_t requestedShotHeight = 0;
+
+uint32_t sampleColors(int n, uint32_t sources[])
+{
+    float red = 0;
+    float green = 0;
+    float blue = 0;
+
+    int i;
+    for (i = 0; i < n; i++)
+    {
+        uint32_t color = sources[i];
+        red += ((color & 0x00FF0000) >> 16) / n;
+        green += ((color & 0x0000FF00) >> 8) / n;
+        blue += (color & 0x000000FF) / n;
+    }
+
+    return (255 << 24) | (((char) red) << 16) | (((char) green) << 8) | ((char) blue);
+}
+
+uint32_t getPixel(int32_t dx, int32_t dy)
+{
+    dx = (uint32_t) (dx * SHOT_SCALE);
+    dy = (uint32_t) (dy * SHOT_SCALE);
+
+    uint32_t x = 0;
+    uint32_t y = 0;
+
+    switch (screenRotation)
+    {
+    case ROTATION_90:
+        // turned counter-clockwise;  invert some of the things
+        x = (dy >= 0) ? (shotWidth - 1 - dy) : -dy;
+        y = (dx >= 0) ? dx : (shotHeight - 1 + dx);
+        break;
+    case ROTATION_180:
+        // turned upside down; invert all the things
+        x = (dx >= 0) ? (shotWidth - 1 - dx) : -dx;
+        y = (dy >= 0) ? (shotHeight - 1 - dy) : -dy;
+        break;
+    case ROTATION_270:
+        // turned clockwise; invert some of the things
+        x = (dy >= 0) ? dy : (shotWidth - 1 + dy);
+        y = (dx >= 0) ? (shotHeight - 1 - dx) : -dx;
+        break;
+    case ROTATION_0:
+    default: // Just smile and wave, boys. Smile and wave.
+        // natural orientation; don't invert anything
+        x = (dx >= 0) ? dx : (shotWidth - 1 + dx);
+        y = (dy >= 0) ? dy : (shotHeight - 1 + dy);
+        break;
+    }
+
+    if (x >= shotWidth)
+    {
+        x = shotWidth - 1;
+    }
+
+    if (y >= shotHeight)
+    {
+        y = shotHeight - 1;
+    }
+
+    if (shotFormat == PIXEL_FORMAT_RGBA_8888)
+    {
+        // this is stored as BGRA behind the scenes, it seems
+        // wonders of interacting with the lower level
+
+        uint32_t color = * (uint32_t *) (((char *) shotBase) + y * shotStride * 4 + x * 4);
+
+        char blue = (color & 0x00FF0000) >> 16;
+        char green = (color & 0x0000FF00) >> 8;
+        char red = color & 0x000000FF;
+
+        return (255 << 24) | (red << 16) | (green << 8) | blue;
+    }
+    else if (shotFormat == PIXEL_FORMAT_RGB_565)
+    {
+        uint16_t color = * (uint16_t *) (((char *) shotBase) + y * shotStride * 2 + x * 2);
+
+        uint32_t red = ((color & 0xF800) >> 11) * 255 / 31;
+        uint32_t green = ((color & 0x07E0) >> 5) * 255 / 63;
+        uint32_t blue = (color & 0x001F) * 255 / 31;
+
+        return (255 << 24) | (red << 16) | (green << 8) | blue;
+    }
+
+    return 0;
+}
+
+JNIEXPORT void JNICALL Java_in_parashit_BarBackgroundUpdaterNative_setScreenSize
+        (JNIEnv *, jclass, jint rotation, jint width, jint height)
+{
+    screenRotation = rotation;
+
+    bool isNatural = rotation != ROTATION_90 && rotation != ROTATION_270;
+    requestedShotWidth = (isNatural ? width : height) * SHOT_SCALE;
+    requestedShotHeight = (isNatural ? height : width) * SHOT_SCALE;
+}
+
+JNIEXPORT jintArray JNICALL Java_in_parashit_BarBackgroundUpdaterNative_getColors
+        (JNIEnv * je, jclass, jint rotation, jint statusBarHeight, jint navigationBarHeight, jint xFromRightSide)
+{
+    jint response[4] = { 0, 0, 0, 0 };
+
+    sp<IBinder> display = SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain);
+    ScreenshotClient screenshot;
+
+    if (display == NULL)
+    {
+        jintArray arr = je->NewIntArray(4);
+        je->SetIntArrayRegion(arr, 0, 4, response);
+        return arr;
+    }
+
+    screenRotation = rotation;
+
+    if (screenshot.update(display, Rect(), SHOT_SCALE == 1 ? 0 : requestedShotWidth, SHOT_SCALE == 1 ? 0 : requestedShotHeight, INT32_MIN, INT32_MAX, false, ISurfaceComposer::eRotateNone) != NO_ERROR)
+    {
+        jintArray arr = je->NewIntArray(4);
+        je->SetIntArrayRegion(arr, 0, 4, response);
+        return arr;
+    }
+
+    shotBase = screenshot.getPixels();
+
+    if (shotBase == NULL)
+    {
+        jintArray arr = je->NewIntArray(4);
+        je->SetIntArrayRegion(arr, 0, 4, response);
+        return arr;
+    }
+
+    shotWidth = screenshot.getWidth();
+    shotHeight = screenshot.getHeight();
+    shotStride = screenshot.getStride();
+    shotFormat = screenshot.getFormat();
+
+    int fsbh = 2 + statusBarHeight;
+    uint32_t colorTopLeft = getPixel(1, fsbh);
+    uint32_t colorTopLeftPadding = getPixel(1 + 10, fsbh);
+    uint32_t colorTopRight = getPixel(-1 - xFromRightSide, fsbh);
+    uint32_t colorTopRightPadding = getPixel(-1 - xFromRightSide - 10, fsbh);
+
+    if (colorTopLeft == colorTopRight)
+    {
+        // status bar appears to be completely uniform
+        response[0] = colorTopLeft;
+    }
+    else if (colorTopRightPadding == colorTopRight)
+    {
+        // the right side of the status bar appears to be uniform
+        response[0] = colorTopRight;
+    }
+    else if (colorTopLeftPadding == colorTopLeft)
+    {
+        // the left side of the status bar appears to be uniform
+        response[0] = colorTopLeft;
+    }
+    else
+    {
+        // status bar does not appear to be uniform at all
+        uint32_t colorsTop[4] = { colorTopLeft, colorTopLeftPadding, colorTopRight, colorTopRightPadding };
+        response[0] = sampleColors(4, colorsTop);
+    }
+
+    response[1] = getPixel(1, 1) == getPixel(1, 5) ? 1 : 0;
+
+    int fnbh = -2 - navigationBarHeight;
+    uint32_t colorBotLeft = getPixel(1, fnbh);
+    uint32_t colorBotLeftPadding = getPixel(1 + 10, fnbh);
+    uint32_t colorBotRight = getPixel(-1 - xFromRightSide, fnbh);
+    uint32_t colorBotRightPadding = getPixel(-1 - xFromRightSide - 10, fnbh);
+
+    if (colorBotLeft == colorBotRight)
+    {
+        // navigation bar appears to be completely uniform
+        response[2] = colorBotLeft;
+    }
+    else if (colorBotRightPadding == colorBotRight)
+    {
+        // the right side of the navigation bar appears to be uniform
+        response[2] = colorBotRight;
+    }
+    else if (colorBotLeftPadding == colorBotLeft)
+    {
+        // the left side of the navigation bar appears to be uniform
+        response[2] = colorBotLeft;
+    }
+    else
+    {
+        // navigation bar does not appear to be uniform at all
+        uint32_t colorsBot[4] = { colorBotLeft, colorBotLeftPadding, colorBotRight, colorBotRightPadding };
+        response[2] = sampleColors(4, colorsBot);
+    }
+
+    response[3] = getPixel(-1, -1) == getPixel(-1, -5) ? 1 : 0;
+
+    jintArray arr = je->NewIntArray(4);
+    je->SetIntArrayRegion(arr, 0, 4, response);
+
+    return arr;
+}
diff --git a/packages/SystemUI/jni/in_parashit_BarBackgroundUpdaterNative.h b/packages/SystemUI/jni/in_parashit_BarBackgroundUpdaterNative.h
new file mode 100644
index 0000000..d688adb
--- /dev/null
+++ b/packages/SystemUI/jni/in_parashit_BarBackgroundUpdaterNative.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 ParanoidAndroid Project
+ *           (C) 2016-2018 ParaSHIT
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* DO NOT EDIT THIS FILE - it is machine generated */
+#include <jni.h>
+/* Header for class in_parashit_BarBackgroundUpdaterNative */
+
+#ifndef _Included_in_parashit_BarBackgroundUpdaterNative
+#define _Included_in_parashit_BarBackgroundUpdaterNative
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Class:     in_parashit_BarBackgroundUpdaterNative
+ * Method:    getColors
+ * Signature: (IIII)[I
+ */
+JNIEXPORT jintArray JNICALL Java_in_parashit_BarBackgroundUpdaterNative_getColors
+  (JNIEnv *, jclass, jint, jint, jint, jint);
+
+/*
+ * Class:     in_parashit_BarBackgroundUpdaterNative
+ * Method:    setScreenSize
+ * Signature: (III)V
+ */
+JNIEXPORT void JNICALL Java_in_parashit_BarBackgroundUpdaterNative_setScreenSize
+  (JNIEnv *, jclass, jint, jint, jint);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarBackgroundUpdater.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarBackgroundUpdater.java
new file mode 100644
index 0000000..30a2375
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarBackgroundUpdater.java
@@ -0,0 +1,439 @@
+/*
+ * Copyright (C) 2014 ParanoidAndroid Project
+ *           (C) 2016-2018 ParaSHIT
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.phone;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.graphics.Color;
+import android.graphics.Point;
+import android.os.Handler;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.view.Display;
+import android.view.Surface;
+import android.view.WindowManager;
+
+import in.parashit.BarBackgroundUpdaterNative;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+
+public class BarBackgroundUpdater {
+    private static long sMinDelay = 50; // time to enforce between the screenshots
+    private static boolean PAUSED = true;
+
+    private final static BroadcastReceiver RECEIVER = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            synchronized (BarBackgroundUpdater.class) {
+                if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                    pause();
+                } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                    resume();
+                }
+            }
+        }
+
+    };
+
+    private final static Thread THREAD = new Thread(new Runnable() {
+
+        @Override
+        public void run() {
+            while (true) {
+                if (PAUSED) {
+                    // we have been told to do nothing; wait for notify to continue
+                    synchronized (BarBackgroundUpdater.class) {
+                        try {
+                            BarBackgroundUpdater.class.wait();
+                        } catch (InterruptedException e) {
+                            return;
+                        }
+                    }
+                    continue;
+                }
+
+                if (mStatusEnabled || mNavigationEnabled) {
+                    final Context context = mContext;
+
+                    if (context == null) {
+                        // we haven't been initiated yet; retry in a bit
+                        try {
+                            Thread.sleep(50);
+                        } catch (InterruptedException e) {
+                            return;
+                        }
+                        continue;
+                    }
+
+                    final WindowManager wm =
+                            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+
+                    final int rotation = wm.getDefaultDisplay().getRotation();
+                    final boolean isLandscape = rotation == Surface.ROTATION_90 ||
+                            rotation == Surface.ROTATION_270;
+
+                    final Resources r = context.getResources();
+                    final int statusBarHeight = r.getDimensionPixelSize(
+                            r.getIdentifier("status_bar_height", "dimen", "android"));
+                    final int navigationBarHeight = r.getDimensionPixelSize(
+                            r.getIdentifier("navigation_bar_height" + (isLandscape ?
+                                    "_landscape" : ""), "dimen", "android"));
+
+                    if (navigationBarHeight <= 0 && mNavigationEnabled) {
+                        // the navigation bar height is not positive - no dynamic navigation bar
+                        Settings.System.putInt(context.getContentResolver(),
+                                Settings.System.DYNAMIC_NAVIGATION_BAR_STATE, 0);
+                        // configuration has changed - abort and retry in a bit
+                        try {
+                            Thread.sleep(50);
+                        } catch (InterruptedException e) {
+                            return;
+                        }
+                        continue;
+                    }
+
+                    final int[] colors = BarBackgroundUpdaterNative.getColors(rotation,
+                            statusBarHeight, navigationBarHeight, 2 + (isLandscape
+                                    ? navigationBarHeight : 0));
+
+                    if (mStatusEnabled) {
+                        statusBarOverrideColor = mStatusFilterEnabled ?
+                                filter(colors[0], -10) : colors[0];
+                        updateStatusBarColor(statusBarOverrideColor);
+                        // magic from http://www.w3.org/TR/AERT#color-contrast
+                        final float statusBarBrightness =
+                                (0.299f * Color.red(statusBarOverrideColor) +
+                                0.587f * Color.green(statusBarOverrideColor) +
+                                0.114f * Color.blue(statusBarOverrideColor)) / 255;
+                        final boolean isStatusBarConsistent = colors[1] == 1;
+                        updateStatusBarIconColor(statusBarBrightness > 0.7f &&
+                                isStatusBarConsistent ? Color.parseColor("#FF000000")
+                                        : Color.parseColor("#FFFFFFFF"));
+                    } else {
+                        // dynamic status bar is disabled
+                        updateStatusBarColor(0);
+                        updateStatusBarIconColor(0);
+                    }
+
+                    if (mNavigationEnabled) {
+                        navigationBarOverrideColor = colors[2];
+                        updateNavigationBarColor(navigationBarOverrideColor);
+                        // magic from http://www.w3.org/TR/AERT#color-contrast
+                        final float navigationBarBrightness =
+                                (0.299f * Color.red(navigationBarOverrideColor) +
+                                0.587f * Color.green(navigationBarOverrideColor) +
+                                0.114f * Color.blue(navigationBarOverrideColor)) / 255;
+                        final boolean isNavigationBarConsistent = colors[3] == 1;
+                        updateNavigationBarIconColor(navigationBarBrightness > 0.7f &&
+                                isNavigationBarConsistent ? Color.parseColor("#FF000000")
+                                        : Color.parseColor("#FFFFFFFF"));
+                    } else {
+                        // dynamic navigation bar is disabled
+                        updateNavigationBarColor(0);
+                        updateNavigationBarIconColor(0);
+                    }
+                } else {
+                    // we are disabled completely - shush
+                    updateStatusBarColor(0);
+                    updateStatusBarIconColor(0);
+                    updateNavigationBarColor(0);
+                    updateNavigationBarIconColor(0);
+                }
+
+                // do a quick cleanup of the listener list
+                synchronized (BarBackgroundUpdater.class) {
+                    final ArrayList<UpdateListener> removables = new ArrayList<UpdateListener>();
+
+                    for (final UpdateListener listener : mListeners) {
+                        if (listener.shouldGc()) {
+                            removables.add(listener);
+                        }
+                    }
+
+                    for (final UpdateListener removable : removables) {
+                        mListeners.remove(removable);
+                    }
+                }
+
+                try {
+                    Thread.sleep(sMinDelay);
+                } catch (InterruptedException e) {
+                    return;
+                }
+            }
+        }
+
+    });
+
+    static {
+        THREAD.setPriority(5);
+        THREAD.start();
+    }
+
+    private static int filter(final int original, final float diff) {
+        final int red = (int) (Color.red(original) + diff);
+        final int green = (int) (Color.green(original) + diff);
+        final int blue = (int) (Color.blue(original) + diff);
+
+        return Color.argb(
+                Color.alpha(original),
+                red > 0 ?
+                        red < 255 ?
+                                red :
+                                255 :
+                        0,
+                green > 0 ?
+                        green < 255 ?
+                                green :
+                                255 :
+                        0,
+                blue > 0 ?
+                        blue < 255 ?
+                                blue :
+                                255 :
+                        0
+        );
+    }
+
+
+    private static final ArrayList<UpdateListener> mListeners = new ArrayList<UpdateListener>();
+    private static Handler mHandler = null;
+    private static SettingsObserver mObserver = null;
+
+    public static boolean mNavigationEnabled = false;
+    public static boolean mStatusEnabled = false;
+    private static boolean mStatusFilterEnabled = false;
+
+    public static int mNavigationBarIconOverrideColor = 0;
+    public static int mNavigationBarOverrideColor = 0;
+    public static int mPreviousNavigationBarIconOverrideColor = 0;
+    public static int mPreviousNavigationBarOverrideColor = 0;
+    public static int mPreviousStatusBarIconOverrideColor = 0;
+    public static int mPreviousStatusBarOverrideColor = 0;
+    public static int mStatusBarIconOverrideColor = 0;
+    public static int mStatusBarOverrideColor = 0;
+
+    public static int navigationBarOverrideColor;
+    public static int statusBarOverrideColor;
+
+    public static Context mContext = null;
+
+    private BarBackgroundUpdater() {}
+
+    private synchronized static void setPauseState(final boolean isPaused) {
+        PAUSED = isPaused;
+        if (!isPaused) {
+            // the thread should be notified to resume
+            BarBackgroundUpdater.class.notify();
+        }
+    }
+
+    private static void pause() {
+        setPauseState(true);
+    }
+
+    private static void resume() {
+        setPauseState(false);
+    }
+
+    public synchronized static void init(final Context context) {
+        if (mContext != null) {
+            mContext.unregisterReceiver(RECEIVER);
+
+            if (mObserver != null) {
+                mContext.getContentResolver().unregisterContentObserver(mObserver);
+            }
+        }
+
+        mHandler = new Handler();
+        mContext = context;
+
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        mContext.registerReceiver(RECEIVER, filter);
+
+        if (mObserver == null) {
+            mObserver = new SettingsObserver(new Handler());
+        }
+
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.DYNAMIC_STATUS_BAR_STATE),
+                false, mObserver, UserHandle.USER_ALL);
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.DYNAMIC_NAVIGATION_BAR_STATE),
+                false, mObserver, UserHandle.USER_ALL);
+        mContext.getContentResolver().registerContentObserver(
+                 Settings.System.getUriFor(Settings.System.DYNAMIC_STATUS_BAR_FILTER_STATE),
+                false, mObserver, UserHandle.USER_ALL);
+
+        mStatusEnabled = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.DYNAMIC_STATUS_BAR_STATE, 0,
+                UserHandle.USER_CURRENT) == 1;
+        mNavigationEnabled = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.DYNAMIC_NAVIGATION_BAR_STATE, 0,
+                UserHandle.USER_CURRENT) == 1;
+        mStatusFilterEnabled = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.DYNAMIC_STATUS_BAR_FILTER_STATE, 0,
+                UserHandle.USER_CURRENT) == 1;
+
+        final Display d = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE))
+                .getDefaultDisplay();
+        final Point sizePoint = new Point();
+        d.getRealSize(sizePoint);
+        BarBackgroundUpdaterNative.setScreenSize(d.getRotation(), sizePoint.x, sizePoint.y);
+
+        resume();
+    }
+
+    public synchronized static void addListener(final UpdateListener... listeners) {
+        for (final UpdateListener listener : listeners) {
+            if (listener == null) {
+                continue;
+            }
+
+            listener.onUpdateStatusBarColor(mPreviousStatusBarOverrideColor,
+                    mStatusBarOverrideColor);
+            listener.onUpdateStatusBarIconColor(mPreviousStatusBarIconOverrideColor,
+                    mStatusBarIconOverrideColor);
+            listener.onUpdateNavigationBarColor(mPreviousNavigationBarOverrideColor,
+                    mNavigationBarOverrideColor);
+            listener.onUpdateNavigationBarIconColor(mPreviousNavigationBarIconOverrideColor,
+                    mNavigationBarIconOverrideColor);
+            boolean shouldAdd = true;
+
+            for (final UpdateListener existingListener : mListeners) {
+                if (existingListener == listener) {
+                    shouldAdd = false;
+                }
+            }
+
+            if (shouldAdd) {
+                mListeners.add(listener);
+            }
+        }
+    }
+
+
+    public synchronized static void updateStatusBarColor(final int newColor) {
+        if (mStatusBarOverrideColor == newColor) {
+            return;
+        }
+
+        mPreviousStatusBarOverrideColor = mStatusBarOverrideColor;
+        mStatusBarOverrideColor = newColor;
+
+        for (final UpdateListener listener : mListeners) {
+            listener.onUpdateStatusBarColor(
+                mPreviousStatusBarOverrideColor, mStatusBarOverrideColor);
+        }
+    }
+
+    public synchronized static void updateStatusBarIconColor(final int newColor) {
+        if (mStatusBarIconOverrideColor == newColor) {
+            return;
+        }
+
+        mPreviousStatusBarIconOverrideColor = mStatusBarIconOverrideColor;
+        mStatusBarIconOverrideColor = newColor;
+
+        for (final UpdateListener listener : mListeners) {
+            listener.onUpdateStatusBarIconColor(
+                mPreviousStatusBarIconOverrideColor, mStatusBarIconOverrideColor);
+        }
+    }
+
+    public synchronized static void updateNavigationBarColor(final int newColor) {
+        if (mNavigationBarOverrideColor == newColor) {
+            return;
+        }
+
+        mPreviousNavigationBarOverrideColor = mNavigationBarOverrideColor;
+        mNavigationBarOverrideColor = newColor;
+
+        for (final UpdateListener listener : mListeners) {
+            listener.onUpdateNavigationBarColor(
+                mPreviousNavigationBarOverrideColor, mNavigationBarOverrideColor);
+        }
+    }
+
+    public synchronized static void updateNavigationBarIconColor(final int newColor) {
+        if (mNavigationBarIconOverrideColor == newColor) {
+            return;
+        }
+
+        mPreviousNavigationBarIconOverrideColor = mNavigationBarIconOverrideColor;
+        mNavigationBarIconOverrideColor = newColor;
+
+        for (final UpdateListener listener : mListeners) {
+            listener.onUpdateNavigationBarIconColor(
+                mPreviousNavigationBarIconOverrideColor, mNavigationBarIconOverrideColor);
+        }
+    }
+
+    public static class UpdateListener {
+        private final WeakReference<Object> mRef;
+
+        public UpdateListener(final Object ref) {
+            mRef = new WeakReference<Object>(ref);
+        }
+
+        public final boolean shouldGc() {
+            return mRef.get() == null;
+        }
+
+        public void onUpdateStatusBarColor(final int previousColor, final int color) {
+            //return null;
+        }
+
+        public void onUpdateStatusBarIconColor(final int previousIconColor, final int iconColor) {
+            //return null;
+        }
+
+        public void onUpdateNavigationBarColor(final int previousColor, final int color) {
+            //return null;
+        }
+
+        public void onUpdateNavigationBarIconColor(final int previousIconColor, final int iconColor) {
+            //return null;
+        }
+    }
+
+    private static final class SettingsObserver extends ContentObserver {
+        private SettingsObserver(final Handler handler) {
+            super(handler);
+        }
+
+        @Override
+        public void onChange(final boolean selfChange) {
+            mStatusEnabled = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.DYNAMIC_STATUS_BAR_STATE, 0, UserHandle.USER_CURRENT) == 1;
+            mNavigationEnabled = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.DYNAMIC_NAVIGATION_BAR_STATE, 0, UserHandle.USER_CURRENT) == 1;
+            mStatusFilterEnabled = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.DYNAMIC_STATUS_BAR_FILTER_STATE, 0, UserHandle.USER_CURRENT) == 1;
+        }
+    }
+
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
index 4bca797..a676664 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
@@ -16,8 +16,12 @@
 
 package com.android.systemui.statusbar.phone;
 
+import android.app.Activity;
 import android.app.ActivityManager;
+import android.app.ActivityManager.RunningAppProcessInfo;
+import android.content.Intent;
 import android.content.Context;
+import android.content.pm.ResolveInfo;
 import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.Color;
@@ -29,7 +33,9 @@ import android.graphics.PorterDuffColorFilter;
 import android.graphics.Rect;
 import android.graphics.PorterDuff.Mode;
 import android.graphics.drawable.Drawable;
+import android.os.Handler;
 import android.os.SystemClock;
+import android.provider.Settings;
 import android.util.Log;
 import android.view.View;
 
@@ -37,6 +43,8 @@ import com.android.settingslib.Utils;
 import com.android.systemui.Interpolators;
 import com.android.systemui.R;
 
+import java.util.List;
+
 public class BarTransitions {
     private static final boolean DEBUG = false;
     private static final boolean DEBUG_COLORS = false;
@@ -53,6 +61,8 @@ public class BarTransitions {
     public static final int LIGHTS_OUT_DURATION = 1500;
     public static final int BACKGROUND_DURATION = 200;
 
+    public static Context mContext;
+
     private final String mTag;
     private final View mView;
     private final BarBackgroundDrawable mBarBackground;
@@ -60,11 +70,13 @@ public class BarTransitions {
     private int mMode;
     private boolean mAlwaysOpaque = false;
 
-    public BarTransitions(View view, int gradientResourceId) {
+    public BarTransitions(View view, BarBackgroundDrawable barBackground) {
         mTag = "BarTransitions." + view.getClass().getSimpleName();
         mView = view;
-        mBarBackground = new BarBackgroundDrawable(mView.getContext(), gradientResourceId);
+        mBarBackground = barBackground;
+        mContext = mView.getContext();
         mView.setBackground(mBarBackground);
+
     }
 
     public int getMode() {
@@ -111,7 +123,7 @@ public class BarTransitions {
     protected void applyModeBackground(int oldMode, int newMode, boolean animate) {
         if (DEBUG) Log.d(mTag, String.format("applyModeBackground oldMode=%s newMode=%s animate=%s",
                 modeToString(oldMode), modeToString(newMode), animate));
-        mBarBackground.applyModeBackground(oldMode, newMode, animate);
+        mBarBackground.applyMode(newMode, animate);
     }
 
     public static String modeToString(int mode) {
@@ -126,36 +138,30 @@ public class BarTransitions {
     }
 
     public void finishAnimations() {
-        mBarBackground.finishAnimation();
+        mBarBackground.finishAnimating();
     }
 
     protected boolean isLightsOut(int mode) {
         return mode == MODE_LIGHTS_OUT || mode == MODE_LIGHTS_OUT_TRANSPARENT;
     }
 
-    private static class BarBackgroundDrawable extends Drawable {
-        private final int mOpaque;
-        private final int mSemiTransparent;
-        private final int mTransparent;
-        private final int mWarning;
-        private final Drawable mGradient;
+    protected static class BarBackgroundDrawable extends Drawable {
+        private final Handler mHandler;
+        private int mOpaque;
+        private int mSemiTransparent;
+        private int mTransparent;
+        private int mWarning;
+        private Drawable mGradient;
 
-        private int mMode = -1;
-        private boolean mAnimating;
-        private long mStartTime;
-        private long mEndTime;
+        private int mCurrentMode = -1;
+        private int mCurrentColor = 0;
+        private int mCurrentGradientAlpha = 0;
 
-        private int mGradientAlpha;
-        private int mColor;
         private PorterDuffColorFilter mTintFilter;
         private Paint mPaint = new Paint();
 
-        private int mGradientAlphaStart;
-        private int mColorStart;
-
-
         public BarBackgroundDrawable(Context context, int gradientResourceId) {
-            final Resources res = context.getResources();
+            mHandler = new Handler();
             if (DEBUG_COLORS) {
                 mOpaque = 0xff0000ff;
                 mSemiTransparent = 0x7f0000ff;
@@ -169,15 +175,40 @@ public class BarTransitions {
                 mWarning = Utils.getColorAttr(context, android.R.attr.colorError);
             }
             mGradient = context.getDrawable(gradientResourceId);
+            setCurrentColor(getTargetColor());
+            setCurrentGradientAlpha(getTargetGradientAlpha());
+            invalidateSelf();
+        }
+
+        @Override
+        public void draw(final Canvas canvas) {
+            final int currentColor = mCurrentColor;
+            if (Color.alpha(currentColor) > 0) {
+                mPaint.setColor(currentColor);
+                if (mTintFilter != null) {
+                    mPaint.setColorFilter(mTintFilter);
+                }
+                canvas.drawPaint(mPaint);
+            }
+            final int currentGradientAlpha = mCurrentGradientAlpha;
+            if (currentGradientAlpha > 0) {
+                mGradient.setAlpha(currentGradientAlpha);
+                mGradient.draw(canvas);
+            }
+        }
+
+        @Override
+        public final int getOpacity() {
+            return PixelFormat.TRANSLUCENT;
         }
 
         @Override
-        public void setAlpha(int alpha) {
+        public final void setAlpha(int alpha) {
             // noop
         }
 
         @Override
-        public void setColorFilter(ColorFilter colorFilter) {
+        public final void setColorFilter(ColorFilter colorFilter) {
             // noop
         }
 
@@ -207,82 +238,197 @@ public class BarTransitions {
             mGradient.setBounds(bounds);
         }
 
-        public void applyModeBackground(int oldMode, int newMode, boolean animate) {
-            if (mMode == newMode) return;
-            mMode = newMode;
-            mAnimating = animate;
-            if (animate) {
-                long now = SystemClock.elapsedRealtime();
-                mStartTime = now;
-                mEndTime = now + BACKGROUND_DURATION;
-                mGradientAlphaStart = mGradientAlpha;
-                mColorStart = mColor;
-            }
-            invalidateSelf();
+        protected int getColorOpaque() {
+            return mOpaque;
         }
 
-        @Override
-        public int getOpacity() {
-            return PixelFormat.TRANSLUCENT;
+        protected int getColorwarning() {
+            return mWarning;
         }
 
-        public void finishAnimation() {
-            if (mAnimating) {
-                mAnimating = false;
-                invalidateSelf();
-            }
+        protected int getColorSemiTransparent() {
+            return  mSemiTransparent;
         }
 
-        @Override
-        public void draw(Canvas canvas) {
-            int targetGradientAlpha = 0, targetColor = 0;
-            if (mMode == MODE_WARNING) {
-                targetColor = mWarning;
-            } else if (mMode == MODE_TRANSLUCENT) {
-                targetColor = mSemiTransparent;
-            } else if (mMode == MODE_SEMI_TRANSPARENT) {
-                targetColor = mSemiTransparent;
-            } else if (mMode == MODE_TRANSPARENT || mMode == MODE_LIGHTS_OUT_TRANSPARENT) {
-                targetColor = mTransparent;
-            } else {
-                targetColor = mOpaque;
-            }
+        protected int getColorTransparent() {
+            return mTransparent;
+        }
 
-            if (!mAnimating) {
-                mColor = targetColor;
-                mGradientAlpha = targetGradientAlpha;
-            } else {
-                final long now = SystemClock.elapsedRealtime();
-                if (now >= mEndTime) {
-                    mAnimating = false;
-                    mColor = targetColor;
-                    mGradientAlpha = targetGradientAlpha;
-                } else {
-                    final float t = (now - mStartTime) / (float)(mEndTime - mStartTime);
-                    final float v = Math.max(0, Math.min(
-                            Interpolators.LINEAR.getInterpolation(t), 1));
-                    mGradientAlpha = (int)(v * targetGradientAlpha + mGradientAlphaStart * (1 - v));
-                    mColor = Color.argb(
-                          (int)(v * Color.alpha(targetColor) + Color.alpha(mColorStart) * (1 - v)),
-                          (int)(v * Color.red(targetColor) + Color.red(mColorStart) * (1 - v)),
-                          (int)(v * Color.green(targetColor) + Color.green(mColorStart) * (1 - v)),
-                          (int)(v * Color.blue(targetColor) + Color.blue(mColorStart) * (1 - v)));
+        protected int getGradientAlphaOpaque() {
+            return 0;
+        }
+
+        protected int getGradientAlphaSemiTransparent() {
+            return 0;
+        }
+
+        private final int getTargetColor() {
+            return getTargetColor(mCurrentMode);
+        }
+
+        public boolean isStatusEnabled() {
+            return BarBackgroundUpdater.mStatusEnabled;
+        }
+
+        public boolean isNavigationEnabled() {
+            return BarBackgroundUpdater.mNavigationEnabled;
+        }
+
+        public boolean isKeyguard() {
+            return NotificationPanelView.mKeyguardShowing;
+        }
+
+        public boolean checkApp(String name) {
+            boolean b = false;
+            final ActivityManager am =
+                    (ActivityManager) mContext.getSystemService(Activity.ACTIVITY_SERVICE);
+            List<RunningAppProcessInfo> apps = am.getRunningAppProcesses();
+            for (RunningAppProcessInfo appInfo : apps) {
+                if (appInfo.pkgList != null && (appInfo.pkgList.length > 0)) {
+                    for (String pkg : appInfo.pkgList) {
+                        if (pkg.equals(name)) {
+                            return b = true;
+                        } else {
+                            return b = false;
+                        }
+                    }
                 }
             }
-            if (mGradientAlpha > 0) {
-                mGradient.setAlpha(mGradientAlpha);
-                mGradient.draw(canvas);
+            return b;
+        }
+
+        public boolean isMusicPlayer() {
+            boolean jair = checkApp("aj.jair.music");
+            boolean eleven = checkApp("com.cyanogenmod.eleven");
+            boolean phono = checkApp("com.kabouzeid.gramophone");
+            boolean jet = checkApp("com.jetappfactory.jetaudioplus");
+            boolean sony = checkApp("com.sonyericsson.music");
+            return jair || eleven || phono || jet || sony ? true : false;
+        }
+
+        public boolean isHomeScreen() {
+            boolean b = false;
+            final Intent intent = new Intent(Intent.ACTION_MAIN);
+            String defaultHomePackage = "com.android.launcher";
+            intent.addCategory(Intent.CATEGORY_HOME);
+            final ResolveInfo res = mContext.getPackageManager().resolveActivity(intent, 0);
+            if (res.activityInfo != null && !res.activityInfo.packageName.equals("android")) {
+                defaultHomePackage = res.activityInfo.packageName;
             }
-            if (Color.alpha(mColor) > 0) {
-                mPaint.setColor(mColor);
-                if (mTintFilter != null) {
-                    mPaint.setColorFilter(mTintFilter);
+            final ActivityManager am =
+                    (ActivityManager) mContext.getSystemService(Activity.ACTIVITY_SERVICE);
+            List<RunningAppProcessInfo> apps = am.getRunningAppProcesses();
+            for (RunningAppProcessInfo appInfo : apps) {
+                if (appInfo.pkgList != null && (appInfo.pkgList.length > 0)) {
+                    for (String pkg : appInfo.pkgList) {
+                        if (pkg.equals(defaultHomePackage)) {
+                            return b = true;
+                        } else {
+                            return b = false;
+                        }
+                    }
                 }
-                canvas.drawPaint(mPaint);
             }
-            if (mAnimating) {
-                invalidateSelf();  // keep going
+            return b;
+        }
+
+        private final int getTargetColor(final int mode) {
+            switch (mode) {
+                case MODE_LIGHTS_OUT_TRANSPARENT:
+                    return getColorOpaque();
+                case MODE_TRANSPARENT:
+                    return getColorOpaque();
+                case MODE_WARNING:
+                    return getColorOpaque();
+                case MODE_TRANSLUCENT:
+                    return getColorOpaque();
+                case MODE_SEMI_TRANSPARENT:
+                    return getColorOpaque();
+                default:
+                    return getColorOpaque();
+            }
+        }
+
+        private final int getTargetGradientAlpha() {
+            return getTargetGradientAlpha(mCurrentMode);
+        }
+
+        private final int getTargetGradientAlpha(final int mode) {
+            switch (mode) {
+                case MODE_TRANSPARENT:
+                    return getGradientAlphaOpaque();
+                case MODE_TRANSLUCENT:
+                    return 0xff;
+                case MODE_SEMI_TRANSPARENT:
+                    return getGradientAlphaSemiTransparent();
+                default:
+                    return getGradientAlphaOpaque();
+            }
+        }
+
+        protected final void setCurrentColor(final int color) {
+            mCurrentColor = color;
+        }
+
+        protected final void setCurrentGradientAlpha(final int alpha) {
+            mCurrentGradientAlpha = alpha;
+        }
+
+        public final synchronized void applyMode(final int mode, final boolean animate) {
+            mCurrentMode = mode;
+            mHandler.post(() -> {
+                final int targetColor = getTargetColor(mode);
+                final int targetGradientAlpha = getTargetGradientAlpha(mode);
+                if (targetColor != mCurrentColor ||
+                        targetGradientAlpha != mCurrentGradientAlpha) {
+                    setCurrentColor(targetColor);
+                    setCurrentGradientAlpha(targetGradientAlpha);
+                    invalidateSelf();
+                }
+            });
+        }
+
+        public final void finishAnimating() {
+            mHandler.post(() -> {
+                final int targetColor = getTargetColor();
+                final int targetGradientAlpha = getTargetGradientAlpha();
+                if (targetColor != mCurrentColor ||
+                        targetGradientAlpha != mCurrentGradientAlpha) {
+                    setCurrentColor(targetColor);
+                    setCurrentGradientAlpha(targetGradientAlpha);
+                    invalidateSelf();
+                }
+            });
+        }
+
+        protected final void generateAnimator() {
+            generateAnimator(mCurrentMode);
+        }
+
+        protected final void generateAnimator(final int targetMode) {
+            final int targetColor = getTargetColor(targetMode);
+            final int targetGradientAlpha = getTargetGradientAlpha(targetMode);
+
+            if (targetColor == mCurrentColor && targetGradientAlpha == mCurrentGradientAlpha) {
+                // no values are changing - nothing to do
+                return ;
             }
+
+            mHandler.post(() -> {
+                if (targetColor == mCurrentColor ) {
+                    // color value is not changing - only gradient alpha is changing
+                    setCurrentGradientAlpha(targetGradientAlpha);
+                }
+
+                if (targetGradientAlpha == mCurrentGradientAlpha ) {
+                    // gradient alpha is not changing - only color value is changing
+                    setCurrentColor(targetColor);
+                }
+                setCurrentColor(targetColor);
+                setCurrentGradientAlpha(targetGradientAlpha);
+                invalidateSelf();
+            });
+
         }
     }
 }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/LightBarController.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/LightBarController.java
index 13617f1..b478c23 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/LightBarController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/LightBarController.java
@@ -20,6 +20,7 @@ import android.app.WallpaperColors;
 import android.content.Context;
 import android.graphics.Color;
 import android.graphics.Rect;
+import android.os.Handler;
 import android.view.View;
 
 import com.android.internal.colorextraction.ColorExtractor.GradientColors;
@@ -74,11 +75,56 @@ public class LightBarController implements BatteryController.BatteryStateChangeC
     private final Rect mLastDockedBounds = new Rect();
     private boolean mQsCustomizing;
 
+    private int mNavigationBarOverrideIconColor = 0;
+    private int mPreviousOverrideNavigationBarIconColor = 0;
+    private int mPreviousOverrideStatusBarIconColor = 0;
+    private int mStatusBarOverrideIconColor = 0;
+
+    public Handler mHandler;
+
     public LightBarController(Context ctx) {
+        mHandler = new Handler();
         mDarkModeColor = Color.valueOf(ctx.getColor(R.color.dark_mode_icon_color_single_tone));
         mStatusBarIconController = Dependency.get(DarkIconDispatcher.class);
         mBatteryController = Dependency.get(BatteryController.class);
         mBatteryController.addCallback(this);
+
+        BarBackgroundUpdater.addListener(new BarBackgroundUpdater.UpdateListener(this) {
+            @Override
+            public void onUpdateStatusBarIconColor(final int previousIconColor,
+                    final int iconColor) {
+                mPreviousOverrideStatusBarIconColor = previousIconColor;
+                mStatusBarOverrideIconColor = iconColor;
+                mHandler.post(() -> {
+                    if (!BarBackgroundUpdater.mStatusEnabled) {
+                        return;
+                    } else if (BarBackgroundUpdater.mStatusEnabled) {
+                        boolean isBlack = mStatusBarOverrideIconColor == 0xFFFFFFFF
+                                ? false : true;
+                        mStatusBarIconController.getTransitionsController().setIconsDark(
+                            isBlack, animateChange());
+                    }
+                });
+            }
+
+            @Override
+            public void onUpdateNavigationBarIconColor(final int previousIconColor,
+                    final int iconColor) {
+                mPreviousOverrideNavigationBarIconColor = previousIconColor;
+                mNavigationBarOverrideIconColor = iconColor;
+                mHandler.post(() -> {
+                    if (!BarBackgroundUpdater.mNavigationEnabled) {
+                        return;
+                    } else if (BarBackgroundUpdater.mNavigationEnabled) {
+                        boolean isBlack = mNavigationBarOverrideIconColor == 0xFFFFFFFF
+                                ? false : true;
+                        if (mNavigationBarController != null) {
+                            mNavigationBarController.setIconsDark(isBlack, animateChange());
+                        }
+                    }
+                });
+            }
+        });
     }
 
     public void setNavigationBar(LightBarTransitionsController navigationBar) {
@@ -191,38 +237,41 @@ public class LightBarController implements BatteryController.BatteryStateChangeC
 
     private void updateStatus(Rect fullscreenStackBounds, Rect dockedStackBounds) {
         boolean hasDockedStack = !dockedStackBounds.isEmpty();
+        if (!BarBackgroundUpdater.mStatusEnabled) {
+            // If both are light or fullscreen is light and there is no docked stack, all icons get
+            // dark.
+            if ((mFullscreenLight && mDockedLight) || (mFullscreenLight && !hasDockedStack)) {
+                mStatusBarIconController.setIconsDarkArea(null);
+                mStatusBarIconController.getTransitionsController().setIconsDark(true, animateChange());
 
-        // If both are light or fullscreen is light and there is no docked stack, all icons get
-        // dark.
-        if ((mFullscreenLight && mDockedLight) || (mFullscreenLight && !hasDockedStack)) {
-            mStatusBarIconController.setIconsDarkArea(null);
-            mStatusBarIconController.getTransitionsController().setIconsDark(true, animateChange());
-
-        }
+            }
 
-        // If no one is light or the fullscreen is not light and there is no docked stack,
-        // all icons become white.
-        else if ((!mFullscreenLight && !mDockedLight) || (!mFullscreenLight && !hasDockedStack)) {
-            mStatusBarIconController.getTransitionsController().setIconsDark(
-                    false, animateChange());
-        }
+            // If no one is light or the fullscreen is not light and there is no docked stack,
+            // all icons become white.
+            else if ((!mFullscreenLight && !mDockedLight) || (!mFullscreenLight && !hasDockedStack)) {
+                mStatusBarIconController.getTransitionsController().setIconsDark(
+                        false, animateChange());
+            }
 
-        // Not the same for every stack, magic!
-        else {
-            Rect bounds = mFullscreenLight ? fullscreenStackBounds : dockedStackBounds;
-            if (bounds.isEmpty()) {
-                mStatusBarIconController.setIconsDarkArea(null);
-            } else {
-                mStatusBarIconController.setIconsDarkArea(bounds);
+            // Not the same for every stack, magic!
+            else {
+                Rect bounds = mFullscreenLight ? fullscreenStackBounds : dockedStackBounds;
+                if (bounds.isEmpty()) {
+                    mStatusBarIconController.setIconsDarkArea(null);
+                } else {
+                    mStatusBarIconController.setIconsDarkArea(bounds);
+                }
+                mStatusBarIconController.getTransitionsController().setIconsDark(true, animateChange());
             }
-            mStatusBarIconController.getTransitionsController().setIconsDark(true, animateChange());
         }
     }
 
     private void updateNavigation() {
         if (mNavigationBarController != null) {
-            mNavigationBarController.setIconsDark(
-                    mNavigationLight, animateChange());
+            if (!BarBackgroundUpdater.mNavigationEnabled) {
+                mNavigationBarController.setIconsDark(
+                        mNavigationLight, animateChange());
+            }
         }
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarTransitions.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarTransitions.java
index b81a3b0..4d29a8f 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarTransitions.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarTransitions.java
@@ -17,9 +17,13 @@
 package com.android.systemui.statusbar.phone;
 
 import android.content.Context;
+import android.database.ContentObserver;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.RemoteException;
 import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.provider.Settings;
 import android.util.SparseArray;
 import android.view.Display;
 import android.view.IWallpaperVisibilityListener;
@@ -43,7 +47,7 @@ public final class NavigationBarTransitions extends BarTransitions {
     private boolean mAutoDim;
 
     public NavigationBarTransitions(NavigationBarView view) {
-        super(view, R.drawable.nav_background);
+        super(view, new NavigationBarBackgroundDrawable(view.getContext()));
         mView = view;
         mBarService = IStatusBarService.Stub.asInterface(
                 ServiceManager.getService(Context.STATUS_BAR_SERVICE));
@@ -156,4 +160,93 @@ public final class NavigationBarTransitions extends BarTransitions {
             return false;
         }
     };
+
+    protected static class NavigationBarBackgroundDrawable
+            extends BarTransitions.BarBackgroundDrawable {
+        private final Context mContext;
+
+        private int mOverrideColor = 0;
+        private int mOverrideGradientAlpha = 0;
+
+        public NavigationBarBackgroundDrawable(final Context context) {
+            super(context, R.drawable.nav_background);
+
+            mContext = context;
+
+            final GradientObserver obs =
+                    new GradientObserver(this, new Handler());
+            (mContext.getContentResolver()).registerContentObserver(
+                    GradientObserver.DYNAMIC_SYSTEM_BARS_GRADIENT_URI,
+                            false, obs, UserHandle.USER_ALL);
+
+            mOverrideGradientAlpha =
+                    Settings.System.getInt(mContext.getContentResolver(),
+                            Settings.System.DYNAMIC_SYSTEM_BARS_GRADIENT_STATE,
+                                    0) == 1 ? 0xff : 0;
+
+            BarBackgroundUpdater.addListener(new BarBackgroundUpdater
+                    .UpdateListener(this) {
+
+                @Override
+                public void onUpdateNavigationBarColor(final int previousColor,
+                        final int color) {
+                    mOverrideColor = color;
+                    generateAnimator();
+                }
+
+            });
+            BarBackgroundUpdater.init(context);
+        }
+
+        @Override
+        protected int getColorOpaque() {
+            return mOverrideColor == 0 ? isNavigationEnabled()
+                    ? super.getColorOpaque() : super.getColorTransparent()
+                    : isHomeScreen() || isKeyguard() || isMusicPlayer()
+                    ? 0x00000000 : mOverrideColor;
+        }
+
+        @Override
+        protected int getColorSemiTransparent() {
+            return mOverrideColor == 0 ? super.getColorSemiTransparent()
+                    : (mOverrideColor & 0x00ffffff | 0x7f000000);
+        }
+
+        @Override
+        protected int getGradientAlphaOpaque() {
+            return mOverrideGradientAlpha;
+        }
+
+        @Override
+        protected int getGradientAlphaSemiTransparent() {
+            return mOverrideGradientAlpha & 0x7f;
+        }
+
+        public void setOverrideGradientAlpha(final int alpha) {
+            mOverrideGradientAlpha = alpha;
+            generateAnimator();
+        }
+    }
+
+    private static final class GradientObserver extends ContentObserver {
+        private static final Uri DYNAMIC_SYSTEM_BARS_GRADIENT_URI =
+                Settings.System.getUriFor(
+                        Settings.System.DYNAMIC_SYSTEM_BARS_GRADIENT_STATE);
+
+        private final NavigationBarBackgroundDrawable mDrawable;
+
+        private GradientObserver(final NavigationBarBackgroundDrawable drawable,
+                final Handler handler) {
+            super(handler);
+            mDrawable = drawable;
+        }
+
+        @Override
+        public void onChange(final boolean selfChange) {
+            mDrawable.setOverrideGradientAlpha(Settings.System.getInt(
+                    mDrawable.mContext.getContentResolver(),
+                            Settings.System.DYNAMIC_SYSTEM_BARS_GRADIENT_STATE,
+                                    0) == 1 ? 0xff : 0);
+        }
+    }
 }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
index 5403879..41492ee 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
@@ -153,7 +153,7 @@ public class NotificationPanelView extends PanelView implements
     private boolean mQsExpanded;
     private boolean mQsExpandedWhenExpandingStarted;
     private boolean mQsFullyExpanded;
-    private boolean mKeyguardShowing;
+    public static boolean mKeyguardShowing;
     private boolean mDozing;
     private boolean mDozingOnDown;
     protected int mStatusBarState;
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
index b236294..16e769e 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarTransitions.java
@@ -19,7 +19,13 @@ package com.android.systemui.statusbar.phone;
 import android.animation.Animator;
 import android.animation.AnimatorSet;
 import android.animation.ObjectAnimator;
+import android.content.Context;
 import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.UserHandle;
+import android.provider.Settings;
 import android.view.View;
 
 import com.android.systemui.R;
@@ -36,7 +42,7 @@ public final class PhoneStatusBarTransitions extends BarTransitions {
     private Animator mCurrentAnimation;
 
     public PhoneStatusBarTransitions(PhoneStatusBarView view) {
-        super(view, R.drawable.status_background);
+        super(view, new PhoneStatusBarBackgroundDrawable(view.getContext()));
         mView = view;
         final Resources res = mView.getContext().getResources();
         mIconAlphaWhenOpaque = res.getFraction(R.dimen.status_bar_icon_drawing_alpha, 1, 1);
@@ -110,4 +116,93 @@ public final class PhoneStatusBarTransitions extends BarTransitions {
             mClock.setAlpha(newAlphaBC);
         }
     }
+
+    protected static class PhoneStatusBarBackgroundDrawable
+            extends BarTransitions.BarBackgroundDrawable {
+        private final Context mContext;
+
+        private int mOverrideColor = 0;
+        private int mOverrideGradientAlpha = 0;
+
+        public PhoneStatusBarBackgroundDrawable(final Context context) {
+            super(context, R.drawable.status_background);
+
+            mContext = context;
+
+            final GradientObserver obs =
+                    new GradientObserver(this, new Handler());
+            (mContext.getContentResolver()).registerContentObserver(
+                    GradientObserver.DYNAMIC_SYSTEM_BARS_GRADIENT_URI,
+                            false, obs, UserHandle.USER_ALL);
+
+            mOverrideGradientAlpha =
+                    Settings.System.getInt(mContext.getContentResolver(),
+                            Settings.System.DYNAMIC_SYSTEM_BARS_GRADIENT_STATE, 0)
+                                    == 1 ? 0xff : 0;
+
+            BarBackgroundUpdater.addListener(new BarBackgroundUpdater
+                    .UpdateListener(this) {
+
+                @Override
+                public void onUpdateStatusBarColor(final int previousColor,
+                        final int color) {
+                    mOverrideColor = color;
+                    generateAnimator();
+                }
+
+            });
+            BarBackgroundUpdater.init(context);
+        }
+
+        @Override
+        protected int getColorOpaque() {
+            return mOverrideColor == 0 ? isStatusEnabled()
+                ? super.getColorOpaque() : super.getColorTransparent()
+                : isHomeScreen() || isKeyguard() || isMusicPlayer()
+                ? 0x00000000 : mOverrideColor;
+        }
+
+        @Override
+        protected int getColorSemiTransparent() {
+            return mOverrideColor == 0 ? super.getColorSemiTransparent()
+                : (mOverrideColor & 0x00ffffff | 0x7f000000);
+        }
+
+        @Override
+        protected int getGradientAlphaOpaque() {
+            return mOverrideGradientAlpha;
+        }
+
+        @Override
+        protected int getGradientAlphaSemiTransparent() {
+            return mOverrideGradientAlpha & 0x7f;
+        }
+
+        public void setOverrideGradientAlpha(final int alpha) {
+            mOverrideGradientAlpha = alpha;
+            generateAnimator();
+        }
+    }
+
+    private static final class GradientObserver extends ContentObserver {
+        private static final Uri DYNAMIC_SYSTEM_BARS_GRADIENT_URI =
+                Settings.System.getUriFor(
+                        Settings.System.DYNAMIC_SYSTEM_BARS_GRADIENT_STATE);
+
+        private final PhoneStatusBarBackgroundDrawable mDrawable;
+
+        private GradientObserver(final PhoneStatusBarBackgroundDrawable drawable,
+                final Handler handler) {
+            super(handler);
+            mDrawable = drawable;
+        }
+
+        @Override
+        public void onChange(final boolean selfChange) {
+            mDrawable.setOverrideGradientAlpha(Settings.System.getInt(
+                    mDrawable.mContext.getContentResolver(),
+                            Settings.System.DYNAMIC_SYSTEM_BARS_GRADIENT_STATE,
+                                    0) == 1 ? 0xff : 0);
+        }
+    }
 }
\ No newline at end of file
diff --git a/packages/SystemUI/src/in/parashit/BarBackgroundUpdaterNative.java b/packages/SystemUI/src/in/parashit/BarBackgroundUpdaterNative.java
new file mode 100644
index 0000000..8fc723b
--- /dev/null
+++ b/packages/SystemUI/src/in/parashit/BarBackgroundUpdaterNative.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2014 ParanoidAndroid Project
+ *           (C) 2016-2018 ParaSHIT
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package in.parashit;
+
+public class BarBackgroundUpdaterNative {
+    public static native int[] getColors(int rotation, int statusBarHeight,
+            int navigationBarHeight, int xFromRightSide);
+
+    public static native void setScreenSize(int rotation, int width, int height);
+
+    static {
+        System.loadLibrary("ParaSHITjni");
+    }
+}
diff --git a/proto/src/metrics_constants.proto b/proto/src/metrics_constants.proto
index 3cadff2..bfe7e1b 100644
--- a/proto/src/metrics_constants.proto
+++ b/proto/src/metrics_constants.proto
@@ -4617,5 +4617,8 @@ message MetricsEvent {
 
     // Add new aosp constants above this line.
     // END OF AOSP CONSTANTS
+
+    // ParaSHIT
+    PARASHIT = 1500;
   }
 }
-- 
2.7.4

